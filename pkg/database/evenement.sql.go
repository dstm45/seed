// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: evenement.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getAllEvent = `-- name: GetAllEvent :many
SELECT id, nom, description, debut_vente, fin_vente, date_evenement, organisateur, heure_evenement, location_evenement, chemin_photo, categorie, prix_billet, quantite_billet from evenements
`

func (q *Queries) GetAllEvent(ctx context.Context) ([]Evenement, error) {
	rows, err := q.db.Query(ctx, getAllEvent)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evenement
	for rows.Next() {
		var i Evenement
		if err := rows.Scan(
			&i.ID,
			&i.Nom,
			&i.Description,
			&i.DebutVente,
			&i.FinVente,
			&i.DateEvenement,
			&i.Organisateur,
			&i.HeureEvenement,
			&i.LocationEvenement,
			&i.CheminPhoto,
			&i.Categorie,
			&i.PrixBillet,
			&i.QuantiteBillet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEventByID = `-- name: GetEventByID :one
SELECT id, nom, description, debut_vente, fin_vente, date_evenement, organisateur, heure_evenement, location_evenement, chemin_photo, categorie, prix_billet, quantite_billet FROM evenements WHERE id=$1
`

func (q *Queries) GetEventByID(ctx context.Context, id int64) (Evenement, error) {
	row := q.db.QueryRow(ctx, getEventByID, id)
	var i Evenement
	err := row.Scan(
		&i.ID,
		&i.Nom,
		&i.Description,
		&i.DebutVente,
		&i.FinVente,
		&i.DateEvenement,
		&i.Organisateur,
		&i.HeureEvenement,
		&i.LocationEvenement,
		&i.CheminPhoto,
		&i.Categorie,
		&i.PrixBillet,
		&i.QuantiteBillet,
	)
	return i, err
}

const getEventByUserEmail = `-- name: GetEventByUserEmail :many
SELECT ev.id, ev.nom, ev.description, ev.debut_vente, ev.fin_vente, ev.date_evenement, ev.organisateur, ev.heure_evenement, ev.location_evenement, ev.chemin_photo, ev.categorie, ev.prix_billet, ev.quantite_billet FROM evenements ev
LEFT JOIN users u ON ev.organisateur = u.id
WHERE u.email = $1
`

func (q *Queries) GetEventByUserEmail(ctx context.Context, email pgtype.Text) ([]Evenement, error) {
	rows, err := q.db.Query(ctx, getEventByUserEmail, email)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Evenement
	for rows.Next() {
		var i Evenement
		if err := rows.Scan(
			&i.ID,
			&i.Nom,
			&i.Description,
			&i.DebutVente,
			&i.FinVente,
			&i.DateEvenement,
			&i.Organisateur,
			&i.HeureEvenement,
			&i.LocationEvenement,
			&i.CheminPhoto,
			&i.Categorie,
			&i.PrixBillet,
			&i.QuantiteBillet,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const newEvent = `-- name: NewEvent :exec
INSERT INTO 
evenements (nom, description, debut_vente, fin_vente, organisateur, heure_evenement, location_evenement, chemin_photo, categorie, prix_billet, quantite_billet)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
`

type NewEventParams struct {
	Nom               pgtype.Text      `json:"nom"`
	Description       string           `json:"description"`
	DebutVente        pgtype.Date      `json:"debut_vente"`
	FinVente          pgtype.Date      `json:"fin_vente"`
	Organisateur      int64            `json:"organisateur"`
	HeureEvenement    pgtype.Timestamp `json:"heure_evenement"`
	LocationEvenement pgtype.Text      `json:"location_evenement"`
	CheminPhoto       pgtype.Text      `json:"chemin_photo"`
	Categorie         pgtype.Text      `json:"categorie"`
	PrixBillet        pgtype.Float8    `json:"prix_billet"`
	QuantiteBillet    pgtype.Int4      `json:"quantite_billet"`
}

func (q *Queries) NewEvent(ctx context.Context, arg NewEventParams) error {
	_, err := q.db.Exec(ctx, newEvent,
		arg.Nom,
		arg.Description,
		arg.DebutVente,
		arg.FinVente,
		arg.Organisateur,
		arg.HeureEvenement,
		arg.LocationEvenement,
		arg.CheminPhoto,
		arg.Categorie,
		arg.PrixBillet,
		arg.QuantiteBillet,
	)
	return err
}
